""" How to use data from one response in another request.

Application Under Test (AUT): https://demoqa.com/books
API Docs: https://demoqa.com/swagger

In this example, we will:

1. Create a new User with one request
2. Authorize that User with another request which returns a Bearer token
3. Then GET that User using the token from the previous request

You will also see how we can create flow functions that combine multiple functions together for common tasks.
In this case, creating an authorized User.

To run the code and tests in this file, run:

    $ poetry run pytest flows/test_use_data_from_response_in_another_request.py
"""

# The most common library for working with Web APIs in Python is called "requests"
import pytest
import requests
import faker
from typing import Dict, Tuple

# The BASE URL is the same for all routes in the API.
## This constant variable is usually defined in a more global config file.
BASE_URL = "https://demoqa.com"

# The ROUTE (aka ENDPOINT). The address, including path variables, of the endpoint to hit.
ROUTE = "/Account/v1"

# Build the request URL however you want! Variables are pretty awesome!
ACCOUNT_V1_URL = BASE_URL + ROUTE


def create_user(username: str, password: str) -> Dict:
    """Create a new User with the given username and password.

    POST requests usually create something, so it's common to include a "payload" in the request to send.
    In this case, we send a JSON (aka Dictionary in Python) with the username and password the new User will have.
    """
    payload = {"userName": username, "password": password}
    response = requests.post(f"{ACCOUNT_V1_URL}/User", json=payload)
    if not response.ok:
        raise ConnectionError(f"Unable to create user: {response.content}")
    return response.json()


def generate_token(username: str, password: str) -> Dict:
    """Generate an auth token for the User with the given username and password.

    Notice that the ROUTE is the same, but the endpoint - /GenerateToken - is different.
    """
    payload = {"userName": username, "password": password}
    response = requests.post(f"{ACCOUNT_V1_URL}/GenerateToken", json=payload)
    if not response.ok:
        raise ConnectionError(f"Unable to generate token: {response.content}")
    return response.json()


def create_authorized_user(username: str, password: str) -> Tuple[Dict, Dict]:
    """Create a new, authorized User with the given username and password.

    This function combines the create_user() and generate_token() functions into one.
    Creating an authorized User is a common task, so we can create a flow function to do it!
    """
    user = create_user(username, password)
    token = generate_token(username, password)
    return user, token


def get_user(user_id: str, token: str) -> Dict:
    """Get a User from the API given the user_id and token.

    The user_id and token are generated by the create_authorized_user() function.
    Look at the test below to see how we can use variables to share data!
    """
    headers = {"Authorization": f"Bearer {token}"}
    response = requests.get(f"{ACCOUNT_V1_URL}/User/{user_id}", headers=headers)
    if not response.ok:
        raise ConnectionError(f"Unable to get user: {response.content}")
    return response.json()


@pytest.fixture
def credentials() -> Tuple[str, str]:
    """Create fake username and password credentials for a new User.

    In this API:
        * username must be unique
        * password doesn't matter

    Fixture functions are used to set things up before tests and tear things down after tests.
    So, this fixture will create a new username and password combination for every test!
    """
    # faker is a library that generates fake data.
    fake = faker.Faker()
    username = fake.first_name() + fake.last_name()
    password = "P@$$w0rd!"
    return username, password


def test_get_newly_created_user(credentials: Tuple):
    # Arrange
    ## Our credentials are generated by the credentials() fixture.
    username, password = credentials

    # Act
    new_user, new_token = create_authorized_user(username, password)
    ## Extract the user_id and token to be used in the next API call.
    user_id = new_user.get("userID")
    token = new_token.get("token")
    ## Get the new User from the API
    user = get_user(user_id, token)

    # Assert
    ## We should find the User with the same username we just created!
    assert user.get("username") == username
